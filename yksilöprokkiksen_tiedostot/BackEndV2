Backendin sisältö:

Backend pitää sisällään kansioita, jotka pitää sisällään tiedostoja jotka laitan tähän yksitellen

backend kansion nimi on "hyteproject" jonka sisällä on kansiot: db, docs, node-modules, public, src ja test. Kansioiden lisäksi hyteprojektissa on tiedostot: counter.js, index.html, javascript.svg, main.js, package-lock.json, package.json, README.md ja style.css.

kansio: hyteproject/db:

hyteproject/db/create-db-user-sql:

CREATE USER 'healthuser'@'localhost' IDENTIFIED BY 'Healthpass!123';
GRANT ALL PRIVILEGES ON `HealthDiary`.* TO 'healthuser'@'localhost';
FLUSH PRIVILEGES;

SQL luontiskriptitiedosto:

hyteproject/db/health-diary.sql:

DROP DATABASE IF EXISTS HealthDiary;
CREATE DATABASE HealthDiary;
USE HealthDiary;

-- Create a table for users
CREATE TABLE Users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    user_level VARCHAR(10) NOT NULL DEFAULT 'regular'
);
¨
-- Create a table for diary entries
CREATE TABLE DiaryEntries (
    entry_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    entry_date DATE NOT NULL,
    mood VARCHAR(50),
    weight DECIMAL(5,2),
    sleep_hours INT,
    notes TEXT,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

-- Tehdään taulu yksilöprojektia varten

CREATE TABLE TrainingDiary (
    diary_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    entry_date DATE NOT NULL,
    mood INT CHECK (mood BETWEEN 1 AND 10),
    training_time DECIMAL(3,1),
    notes TEXT,
    goals TEXT,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

-- Tehdään taulu HEALTHMETRICS terveystulosten kirjaamiseen

CREATE TABLE HealthMetrics (
    metric_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    measurement_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    blood_pressure_systolic INT,
    blood_pressure_diastolic INT,
    heart_rate INT,
    blood_sugar DECIMAL(5,2),
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);

-- Tehdään taulu MEDICATIONINTAKE lääkkeiden käytön kirjaamiseen
CREATE TABLE MedicationIntake (
    intake_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    intake_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    medication_name VARCHAR(100),
    dosage VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES Users(user_id)
);





-- INSERT User sample data
-- Iserting multiple user rows at once
INSERT INTO Users (username, password, email, user_level) VALUES
  ('johndoe', 'temp-pw-1', 'johndoe@example.com', 'regular'),
  ('janedoe', 'temp-pw-2', 'janedoe@example.com', 'admin'),
  ('mike_smith', 'temp-pw-3', 'mike@example.com', 'moderator');


-- Inserting multiple diary entries
INSERT INTO DiaryEntries (user_id, entry_date, mood, weight, sleep_hours, notes, created_at) VALUES
  (1, '2024-01-10', 'Happy', 70.5, 8, 'Had a great day, felt energetic', '2024-01-10 20:00:00'),
  (1, '2024-01-11', 'Tired', 70.2, 6, 'Long day at work, need rest', '2024-01-11 20:00:00'),
  (2, '2024-01-10', 'Stressed', 65.0, 7, 'Busy day, a bit stressed out', '2023-12-10 21:00:00');

--   Lisätään mittaustietoja HEALTHMETRICS tauluun
INSERT INTO HealthMetrics (user_id, measurement_date, blood_pressure_systolic, blood_pressure_diastolic, heart_rate, blood_sugar) VALUES
    (1, '2024-01-10', 120, 80, 70, 5.4),
    (1, '2024-01-11', 118, 79, 72, 5.5),
    (2, '2024-01-10', 122, 82, 75, 5.3);

    -- Lisätään lääkintätietoja MedicationIntake taluun

    INSERT INTO MedicationInTake (user_id, intake_date, medication_name, dosage) VALUES
(1, '2024-01-10', 'Aspirin', '100mg'),
(1, '2024-01-11', 'Vitamin D', '5000 IU'),
(2, '2024-01-10', 'Ibuprofen', '200mg');




-- Example queries
SELECT Users.username, DiaryEntries.entry_date, DiaryEntries.mood, DiaryEntries.notes
  FROM Users, DiaryEntries
  WHERE DiaryEntries.user_id = Users.user_id;

-- Same with JOIN
SELECT Users.username, DiaryEntries.entry_date, DiaryEntries.mood, DiaryEntries.notes
  FROM Users JOIN DiaryEntries ON DiaryEntries.user_id = Users.user_id;

-- Entries for specific username
SELECT entry_date, mood, sleep_hours FROM DiaryEntries
  JOIN Users ON DiaryEntries.user_id = Users.user_id
  WHERE username = 'johndoe';

kansio: hyteproject/public:

index.html:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>index</title>
</head>
<body>
  <h1>index</h1>
  <p>Staattisen web-sivun voi julkaista tässä kansiossa.</p>
</body>
</html>

sekä vite.svg tiedosto.

kansio src: pitää sisällään kansiot controllers, middlewares, models, routes ja utils:

kansio hyteproject/src/controllers:

auth-controller.mjs:

/**
 * Authentication resource controller
 * @module controllers/auth-controller
 * @author mattpe <mattpe@metropolia.fi>
 * @requires jsonwebtoken
 * @requires bcryptjs
 * @requires dotenv
 * @requires models/user-model
 * @requires middlewares/error-handler
 * @exports postLogin
 * @exports getMe
 */

import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import 'dotenv/config';
import {selectUserByUsername} from '../models/user-model.mjs';
import {customError} from '../middlewares/error-handler.mjs';

/**
 * User login
 * @async
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @return {object} user if username & password match
 */
const postLogin = async (req, res, next) => {
  const {username, password} = req.body;
  console.log('login', req.body);
  const user = await selectUserByUsername(username);
  if (user.error) {
    return res.status(user.error).json(user);
  }
  // compare password and hash, if match, login successful
  const match = await bcrypt.compare(password, user.password);
  if (match) {
    delete user.password;
    const token = jwt.sign(user, process.env.JWT_SECRET, {
      expiresIn: process.env.JWT_EXPIRES_IN,
    });
    return res.json({message: 'Logged in successfully', user, token});
  } else {
    return next(customError('Invalid username or password', 401));
  }
};

/**
 * Get user info from token
 * NOTE! user info is extracted from the token
 * => it is not necessary up to date info (should be refreshed from db)
 * @async
 * @param {object} req
 * @param {object} res
 * @return {object} user info
 */
const getMe = async (req, res) => {
  res.json({user: req.user});
};

export {postLogin, getMe};




entry-controller.mjs:

import {customError} from '../middlewares/error-handler.mjs';
import {
  findEntryById,
  addEntry,
  deleteEntryById,
  updateEntryById,
  listAllEntriesByUserId,
} from '../models/entry-model.mjs';

const getEntries = async (req, res, next) => {
  // return only logged in user's own entries
  // - get user's id from token (req.user.user_id)
  const result = await listAllEntriesByUserId(req.user.user_id);
  if (!result.error) {
    res.json(result);
  } else {
    next(new Error(result.error));
  }
};

const getEntryById = async (req, res, next) => {
  const entry = await findEntryById(req.params.id, req.user.user_id);
  if (entry) {
    res.json(entry);
  } else {
    next(customError('Entry not found', 404));
  }
};

const postEntry = async (req, res, next) => {
  const userId = req.user.user_id;
  const result = await addEntry(req.body, userId);
  if (result.entry_id) {
    res.status(201);
    res.json({message: 'New entry added.', ...result});
  } else {
    next(new Error(result.error));
  }
};

const putEntry = async (req, res, next) => {
  const entryId = req.params.id;
  const userId = req.user.user_id;
  const result = await updateEntryById(entryId, userId, req.body);
  if (result.error) {
    return next(customError(result.message, result.error));
  }
  return res.status(201).json(result);
};

const deleteEntry = async (req, res, next) => {
  const result = await deleteEntryById(req.params.id, req.user.user_id);
  if (result.error) {
    return next(customError(result.message, result.error));
  }
  return res.json(result);
};

export {getEntries, getEntryById, postEntry, putEntry, deleteEntry};






item-controller.mjs:

import items from '../models/item-model.mjs';

const getItems = (req, res) => {
  res.json(items);
};

// palauta vain se objekti, jonka id vastaa pyydettyä, muuten 404
const getItemById = (req, res) => {
  // console.log('requested item id', req.params.id);
  const itemFound = items.find((item) => item.id == req.params.id);
  // console.log('found item', itemFound);
  if (itemFound) {
    res.json(itemFound);
  } else {
    res.status(404).json({error: 'not found'});
  }
};

const postItem = (req, res) => {
  // lisää postattu item items-taulukkoon
  console.log('postItem request body', req.body);
  // error if name property is missing
  if (!req.body.name) {
    return res.status(400).json({error: 'item name missing'});
  }
  // new id: add 1 to last id number in the items array
  const newId = items[items.length - 1].id + 1;
  const newItem = {id: newId, name: req.body.name};
  items.push(newItem);
  res.status(201).json({message: 'item created'});
};

const deleteItem = (req, res) => {
  const index = items.findIndex((item) => item.id == req.params.id);
  if (index === -1) {
    // example how to send only the status code (still valid http response)
    return res.sendStatus(404);
  }
  const deletedItems = items.splice(index, 1);
  console.log('deleteItem:', deletedItems);
  res.json({deleted_item: deletedItems[0]});
  // or successful response without any content
  // res.sendStatus(204);
};

const putItem = (req, res) => {
  // TODO: implement modify item
  const index = items.findIndex((item) => item.id == req.params.id);
  // not found
  if (index === -1) {
    return res.sendStatus(404);
  }
  // bad request
  if (!req.body.name) {
    return res.status(400).json({error: 'item name missing'});
  }
  items[index].name = req.body.name;
  res.json({updated_item: items[index]});
};

export {getItems, getItemById, postItem, deleteItem, putItem};








user-controller.mjs:


import bcrypt from 'bcryptjs';
import {
  deleteUserById,
  insertUser,
  listAllUsers,
  selectUserById,
  updateUserById,
} from '../models/user-model.mjs';
import {customError} from '../middlewares/error-handler.mjs';

/**
 * Get all users
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 * @param {function} next - next function
 */
const getUsers = async (req, res, next) => {
  const result = await listAllUsers();
  if (result.error) {
    return next(customError(result, result.error));
  }
  return res.json(result);
};

const getUserById = async (req, res, next) => {
  const result = await selectUserById(req.params.id);
  if (result.error) {
    return next(customError(result, result.error));
  }
  return res.json(result);
};

const postUser = async (req, res, next) => {
  const {username, password, email} = req.body;
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(password, salt);
  const result = await insertUser(
    {
      username,
      email,
      password: hashedPassword,
    },
    next,
  );
  return res.status(201).json(result);
};

const putUser = async (req, res, next) => {
  // Get userinfo from req.user object extracted from token
  // Only user authenticated by token can update own data
  // TODO: admin user can update any user (incl. user_level)
  const userId = req.user.user_id;
  const {username, password, email} = req.body;
  // hash password if included in request
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(password, salt);
  const result = await updateUserById({
    userId,
    username,
    password: hashedPassword,
    email,
  });
  if (result.error) {
    return next(customError(result, result.error));
  }
  return res.status(200).json(result);
};

const deleteUser = async (req, res, next) => {
  // console.log('deleteUser', req.user, req.params.id);
  // admin user can delete any user
  // user authenticated by token can delete itself
  if (
    req.user.user_level !== 'admin' &&
    req.user.user_id !== parseInt(req.params.id)
  ) {
    return next(customError('Unauthorized', 401));
  }
  const result = await deleteUserById(req.params.id);
  if (result.error) {
    return next(customError(result, result.error));
  }
  return res.json(result);
};

export {getUsers, getUserById, postUser, putUser, deleteUser};






kansio hyteproject/src/middlevares:


authentication.mjs:


import jwt from 'jsonwebtoken';
import 'dotenv/config';
import {customError} from './error-handler.mjs';

const authenticateToken = (req, res, next) => {
  // console.log('authenticateToken', req.headers);
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  // console.log('token', token);
  if (!token) {
    return next(customError('Token missing', 401));
  }
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch (err) {
    next(customError('Invalid token', 401));
  }
};

export {authenticateToken};







error-handler.mjs:

import {validationResult} from 'express-validator';

/**
 * Custom error generator
 * @param {string} message - error message
 * @param {number} [status] - optional error status, default is 500
 * @param {array} [errors] - optional array of error objects
 * @return {object} error object
 */
const customError = (message, status, errors) => {
  const error = new Error(message);
  error.status = status || 500;
  if (errors) {
    error.errors = errors;
  }
  return error;
};

/**
 * Generic 404 handler
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {function} next - next function
 */
const notFoundHandler = (req, res, next) => {
  const error = customError(`Not Found - ${req.originalUrl}`, 404);
  next(error); // forward error to error handler
};

/**
 * Custom default middleware for handling errors
 * @param {object} err - error object
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {function} next - next function
 */
const errorHandler = (err, req, res, next) => {
  res.status(err.status || 500); // default is 500 if err.status is not defined
  console.log('errorHandler', err.message, err.status, err.errors);
  res.json({
    error: {
      message: err.message,
      status: err.status || 500,
      errors: err.errors,
    },
  });
};

/**
 * Custom middleware for handling and formatting validation errors
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {function} next - next function
 * @return {*} next function call
 */
const validationErrorHandler = (req, res, next) => {
  const errors = validationResult(req, {strictParams: ['body']});
  if (!errors.isEmpty()) {
    // console.log('validation errors', errors.array({onlyFirstError: true}));
    const error = customError('Bad Request', 400);
    error.errors = errors.array({onlyFirstError: true}).map((error) => {
      return {field: error.path, message: error.msg};
    });
    return next(error);
  }
  next();
};

export {customError, notFoundHandler, errorHandler, validationErrorHandler};




logger.mjs:

const logger = (req, res, next) => {
  console.log('Logger', req.method, req.path);
  next();
};

export default logger;








kansio hyteproject/src/models:

entry-model.mjs:


import promisePool from '../utils/database.mjs';

const listAllEntries = async () => {
  try {
    const [rows] = await promisePool.query('SELECT * FROM DiaryEntries');
    // console.log('rows', rows);
    return rows;
  } catch (e) {
    console.error('error', e.message);
    return {error: e.message};
  }
};

const listAllEntriesByUserId = async (id) => {
  try {
    const sql = 'SELECT * FROM DiaryEntries WHERE user_id=?';
    const params = [id];
    const [rows] = await promisePool.query(sql, params);
    // console.log('rows', rows);
    return rows;
  } catch (e) {
    console.error('error', e.message);
    return {error: e.message};
  }
};

const findEntryById = async (id, userId) => {
  try {
    const [rows] = await promisePool.query(
      'SELECT * FROM DiaryEntries WHERE entry_id = ? AND user_id = ?',
      [id, userId],
    );
    // console.log('rows', rows);
    return rows[0];
  } catch (e) {
    console.error('error', e.message);
    return {error: e.message};
  }
};

const addEntry = async (entry, userId) => {
  const sql = `INSERT INTO DiaryEntries
               (user_id, entry_date, mood, weight, sleep_hours, notes)
               VALUES (?, ?, ?, ?, ?, ?)`;
  const params = [
    userId,
    entry.entry_date,
    entry.mood,
    entry.weight,
    entry.sleep_hours,
    entry.notes,
  ];
  try {
    const rows = await promisePool.query(sql, params);
    // console.log('rows', rows);
    return {entry_id: rows[0].insertId};
  } catch (e) {
    console.error('error', e.message);
    return {error: e.message};
  }
};

const updateEntryById = async (entryId, userId, entryData) => {
  try {
    const params = [entryData, entryId, userId];
    // format() function is used to include only the fields that exists
    // in the entryData object to the SQL query
    const sql = promisePool.format(
      `UPDATE DiaryEntries SET ?
       WHERE entry_id=? AND user_id=?`,
      params,
    );
    const [result] = await promisePool.query(sql, params);
    // console.log(result);
    if (result.affectedRows === 0) {
      return {error: 404, message: 'Entry not found'};
    }
    return {message: 'Entry data updated', entry_id: entryId};
  } catch (error) {
    // fix error handling
    // now duplicate entry error is generic 500 error, should be fixed to 400 ?
    console.error('updateEntryById', error);
    return {error: 500, message: 'db error'};
  }
};

const deleteEntryById = async (id, userId) => {
  try {
    const sql = 'DELETE FROM DiaryEntries WHERE entry_id=? AND user_id=?';
    const params = [id, userId];
    const [result] = await promisePool.query(sql, params);
    // console.log(result);
    if (result.affectedRows === 0) {
      return {error: 404, message: 'Entry not found'};
    }
    return {message: 'Entry deleted', entry_id: id};
  } catch (error) {
    console.error('deleteEntryById', error);
    return {error: 500, message: 'db error'};
  }
};

export {
  listAllEntries,
  listAllEntriesByUserId,
  findEntryById,
  addEntry,
  updateEntryById,
  deleteEntryById,
};







item-model.mjs:

// mock data for simple API
const items = [
  {id: 1, name: 'Item 1'},
  {id: 2, name: 'Item 2'},
  {id: 3, name: 'Item kolme'},
  {id: 4, name: 'Item neljä'},
];

export default items;








user-model.mjs:

import promisePool from '../utils/database.mjs';

const listAllUsers = async () => {
  try {
    const sql = 'SELECT user_id, username, user_level FROM Users';
    const [rows] = await promisePool.query(sql);
    // console.log(rows);
    return rows;
  } catch (error) {
    console.error('listAllUsers', error);
    return {error: 500, message: 'db error'};
  }
};

const selectUserById = async (id) => {
  try {
    const sql = 'SELECT * FROM Users WHERE user_id=?';
    const params = [id];
    const [rows] = await promisePool.query(sql, params);
    // console.log(rows);
    // if nothing is found with the user id, result array is empty []
    if (rows.length === 0) {
      return {error: 404, message: 'user not found'};
    }
    // Remove password property from result
    delete rows[0].password;
    return rows[0];
  } catch (error) {
    console.error('selectUserById', error);
    return {error: 500, message: 'db error'};
  }
};

const insertUser = async (user, next) => {
  try {
    const sql =
      'INSERT INTO Users (username, password, email) VALUES (?, ?, ?)';
    const params = [user.username, user.password, user.email];
    const [result] = await promisePool.query(sql, params);
    // console.log(result);
    return {message: 'new user created', user_id: result.insertId};
  } catch (error) {
    // now duplicate entry error is generic 500 error, should be fixed to 400 ?
    console.error('insertUser', error);
    // Error handler can be used directly from model, if next function is passed
    return next(new Error(error));
  }
};

const updateUserById = async (user) => {
  try {
    const sql =
      'UPDATE Users SET username=?, password=?, email=? WHERE user_id=?';
    const params = [user.username, user.password, user.email, user.userId];
    await promisePool.query(sql, params);
    const [result] = await promisePool.query(sql, params);
    console.log(result);
    return {message: 'user data updated', user_id: user.userId};
  } catch (error) {
    // now duplicate entry error is generic 500 error, should be fixed to 400 ?
    console.error('updateUserById', error);
    return {error: 500, message: 'db error'};
  }
};

const deleteUserById = async (id) => {
  try {
    const sql = 'DELETE FROM Users WHERE user_id=?';
    const params = [id];
    const [result] = await promisePool.query(sql, params);
    // console.log(result);
    if (result.affectedRows === 0) {
      return {error: 404, message: 'user not found'};
    }
    return {message: 'user deleted', user_id: id};
  } catch (error) {
    // note that users with other data (FK constraint) cant be deleted directly
    console.error('deleteUserById', error);
    return {error: 500, message: 'db error'};
  }
};

// Used for login
const selectUserByUsername = async (username) => {
  try {
    const sql = 'SELECT * FROM Users WHERE username=?';
    const params = [username];
    const [rows] = await promisePool.query(sql, params);
    // console.log(rows);
    // if nothing is found with the username, login attempt has failed
    if (rows.length === 0) {
      return {error: 401, message: 'invalid username or password'};
    }
    return rows[0];
  } catch (error) {
    console.error('selectUserByNameAndPassword', error);
    return {error: 500, message: 'db error'};
  }
};

export {
  listAllUsers,
  selectUserById,
  insertUser,
  updateUserById,
  deleteUserById,
  selectUserByUsername,
};








kansio hyteproject/src/routes:



auth-router.mjs:


import express from 'express';
import {body} from 'express-validator';
import {getMe, postLogin} from '../controllers/auth-controller.mjs';
import {authenticateToken} from '../middlewares/authentication.mjs';
import {validationErrorHandler} from '../middlewares/error-handler.mjs';

const authRouter = express.Router();

/**
 * @apiDefine all No authentication needed.
 */

/**
 * @apiDefine admin Admin users only.
 * Valid authentication token must be provided within request.
 */

/**
 * @apiDefine token Logged in user access only
 * Valid authentication token must be provided within request.
 */

/**
 * @apiDefine UnauthorizedError
 * @apiError UnauthorizedError User name or password invalid.
 * @apiErrorExample Error-Response:
 *    HTTP/1.1 401 Unauthorized
 *    {
 *      "error": 401,
 *      "message": "invalid username or password"
 *    }
 */

/**
 * @apiDefine InvalidTokenError
 * @apiError InvalidToken Authentication token was invalid.
 * @apiErrorExample Error-Response:
 *     HTTP/1.1 401 Unauthorized
 *     {
 *       "message": "invalid token",
 *       "status": 401
 *     }
 */

authRouter
  /**
   * @api {post} /auth/login Login
   * @apiVersion 1.0.0
   * @apiName PostLogin
   * @apiGroup Authentication
   * @apiPermission all
   *
   * @apiDescription Sign in and get an authentication token for the user.
   *
   * @apiParam {String} username Username of the user.
   * @apiParam {String} password Password of the user.
   *
   * @apiParamExample {json} Request-Example:
   *    {
   *      "username": "johnd",
   *      "password": "examplepass"
   *    }
   *
   * @apiSuccess {String} token Token for the user authentication.
   * @apiSuccess {Object} user User info.
   *
   * @apiSuccessExample Success-Response:
   *    HTTP/1.1 200 OK
   *    {
   *      "message": "Logged in successfully",
   *      "token": "TOKEN-VALUE"
   *      "user": {
   *        "user_id": 21,
   *        "username": "johnd",
   *        "email": "johnd@example.com",
   *        "user_level": "regular"
   *      }
   *    }
   *
   * @apiUse UnauthorizedError
   */
  .post(
    '/login',
    body('username').trim().notEmpty(),
    body('password').trim().notEmpty(),
    validationErrorHandler,
    postLogin,
  )
  /**
   * @api {get} /auth/me Request information about current user
   * @apiVersion 1.0.0
   * @apiName GetMe
   * @apiGroup Authentication
   * @apiPermission token
   * @apiHeader {String} Authorization Bearer token.
   *
   * @apiSuccess {Object} user User info.
   * @apiSuccess {Number} user.user_id Id of the User.
   * @apiSuccess {String} user.username Username of the User.
   * @apiSuccess {String} user.email email of the User.
   * @apiSuccess {Date} user.created_at User creation time.
   * @apiSuccess {String} user.user_level User level of the User.
   * @apiSuccess {Number} user.iat Token creation timestamp.
   * @apiSuccess {Number} user.exp Token expiration timestamp.
   *
   * @apiSuccessExample Success-Response:
   * HTTP/1.1 200 OK
   * {
   *   "user": {
   *     "user_id": 18,
   *     "username": "johnjane",
   *     "email": "johnjane@example.com",
   *     "created_at": "2024-03-07T12:45:51.000Z",
   *     "user_level": "regular",
   *     "iat": 1709887124,
   *     "exp": 1709973524
   *   }
   * }
   * @apiUse InvalidTokenError
   */
  .get('/me', authenticateToken, getMe);

export default authRouter;






entry-router.mjs:


import express from 'express';
import {body, param} from 'express-validator';
import {
  getEntries,
  getEntryById,
  postEntry,
  putEntry,
  deleteEntry,
} from '../controllers/entry-controller.mjs';
import {authenticateToken} from '../middlewares/authentication.mjs';
import {validationErrorHandler} from '../middlewares/error-handler.mjs';

const entryRouter = express.Router();

entryRouter
  .route('/')
  .get(authenticateToken, getEntries)
  .post(
    authenticateToken,
    body('entry_date').isDate(),
    body('mood').optional().trim().isLength({min: 3, max: 20}).isString(),
    body('weight').optional().isFloat({min: 30, max: 200}),
    body('sleep_hours').optional().isInt({min: 0, max: 24}),
    body('notes').optional().isString().isLength({min: 3, max: 300}),
    validationErrorHandler,
    postEntry,
  );

entryRouter
  .route('/:id')
  .get(
    authenticateToken,
    param('id', 'must be integer').isInt(),
    validationErrorHandler,
    getEntryById,
  )
  .put(
    authenticateToken,
    param('id', 'must be integer').isInt(),
    // user_id is not allowed to be changed
    body('user_id', 'not allowed').not().exists(),
    body('entry_date').optional().isDate(),
    body('mood').optional().trim().isLength({min: 3, max: 20}).isString(),
    body('weight').optional().isFloat({min: 30, max: 200}),
    body('sleep_hours').optional().isInt({min: 0, max: 24}),
    body('notes').optional().isString().isLength({min: 3, max: 300}),
    validationErrorHandler,
    putEntry,
  )
  .delete(
    authenticateToken,
    param('id', 'must be integer').isInt(),
    validationErrorHandler,
    deleteEntry,
  );

export default entryRouter;







item-router.mjs:

import express from 'express';
import {
  deleteItem,
  getItemById,
  getItems,
  postItem,
  putItem,
} from '../controllers/item-controller.mjs';

const itemRouter = express.Router();

// define routes here
// GET http://127.0.0.1:3000/items
itemRouter.get('/', getItems);
// GET http://127.0.0.1:3000/items/<ID>
itemRouter.get('/:id', getItemById);
// POST http://127.0.0.1:3000/items/ (Itemin lisäys)
itemRouter.post('/', postItem);
// PUT
itemRouter.put('/:id', putItem);
// DELETE
itemRouter.delete('/:id', deleteItem);

export default itemRouter;








user-router.mjs:

import express from 'express';
import {body, param} from 'express-validator';
import {
  getUserById,
  getUsers,
  postUser,
  putUser,
  deleteUser,
} from '../controllers/user-controller.mjs';
import {authenticateToken} from '../middlewares/authentication.mjs';
import {validationErrorHandler} from '../middlewares/error-handler.mjs';

const userRouter = express.Router();

// /api/user endpoint
userRouter
  .route('/')
  /**
   * @api {get} /users Request user list
   * @apiName GetUsers
   * @apiGroup Users
   * @apiPermission token
   *
   * @apiSuccess {Array} user[] array of Users.
   * @apiSuccess {Object} user User object.
   * @apiSuccess {Number} user.user_id Id of the user.
   * @apiSuccess {String} user.username Username
   * @apiSuccess {String} user.user_level Userlevel of the User.
   *
   * TODO: add example response
   *
   * @apiUse InvalidTokenError
   */
  .get(authenticateToken, getUsers)
  // update user
  .put(
    authenticateToken,
    body('username', 'username must be 3-20 characters long and alphanumeric')
      .trim()
      .isLength({min: 3, max: 20})
      .isAlphanumeric(),
    body('password', 'minimum password length is 8 characters')
      .trim()
      .isLength({min: 8, max: 128}),
    body('email', 'must be a valid email address')
      .trim()
      .isEmail()
      .normalizeEmail(),
    validationErrorHandler,
    putUser,
  )
  // user registration
  .post(
    body('username', 'username must be 3-20 characters long and alphanumeric')
      .trim()
      .isLength({min: 3, max: 20})
      .isAlphanumeric(),
    body('password', 'minimum password length is 8 characters')
      .trim()
      .isLength({min: 4, max: 128}),
    body('email', 'must be a valid email address')
      .trim()
      .isEmail()
      .normalizeEmail(),
    validationErrorHandler,
    postUser,
  );

// /user/:id endpoint
userRouter
  .route('/:id')
  // get info of a user
  .get(
    authenticateToken,
    param('id', 'must be integer').isInt(),
    validationErrorHandler,
    getUserById,
  )
  // delete user based on id
  .delete(
    authenticateToken,
    param('id', 'must be integer').isInt(),
    validationErrorHandler,
    deleteUser,
  );

export default userRouter;








kansio hyteproject/src/utils:



database.mjs:

import mysql from 'mysql2';
import 'dotenv/config';

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});
const promisePool = pool.promise();
export default promisePool;







hyteproject/src/index.js:

// Main JS file
import express from 'express';
import path from 'path';
import {fileURLToPath} from 'url';
import itemRouter from './routes/item-router.mjs';
import userRouter from './routes/user-router.mjs';
import entryRouter from './routes/entry-router.mjs';
import cors from 'cors';
import logger from './middlewares/logger.mjs';
import authRouter from './routes/auth-router.mjs';
import {errorHandler, notFoundHandler} from './middlewares/error-handler.mjs';
const hostname = '127.0.0.1';
const port = 3000;
const app = express();

// middleware, joka lisää CORS-otsakkeen jokaiseen lähtevään vastaukseen.
// Eli kerrotaan selaimelle, että tämä palvelin sallii AJAX-pyynnöt
// myös muista kuin samasta alkuperästä (url-osoitteesta, palvelimelta)
// ladatuilta sivuilta.
app.use(cors());

// logger middleware
app.use(logger);

// middleware, joka parsii pyynnössä olevan JSON-datan
// ja lisää sen request-objektiin (req.body)
app.use(express.json());

// Staattinen sivusto palvelimen juureen (public-kansion sisältö näkyy osoitteessa http://127.0.0.1:3000/sivu.html)
// Voit sijoittaa esim. valmiin client-sovelluksen tähän kansioon
app.use(express.static('public'));

// Staattinen sivusto voidaan tarjoilla myös "ali-url-osoitteessa": http://127.0.0.1:3000/sivusto
// Tarjoiltava kansio määritellään relatiivisella polulla
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use('/docs', express.static(path.join(__dirname, '../docs')));

// Test RESOURCE /items endpoints
// (just mock data for testing, not connected to any database)
app.use('/items', itemRouter);

// bind base url (/api/entries resource) for all entry routes to entryRouter
app.use('/api/entries', entryRouter);

// Users resource (/api/users)
app.use('/api/users', userRouter);

// User authentication
app.use('/api/auth', authRouter);

// Default 404 not found
app.use(notFoundHandler);
// Error handler for sending response all error cases
app.use(errorHandler);

// Start the server
app.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
});







hyteproject/src/rnd-tests.mjs:


const calculateSum = (...numbers) => {
  console.log('input values: ', numbers);  //-> input values:  [1, 2, 3, 4, 5] (array)
  return numbers.reduce((acc, number) => acc + number, 0);
}
calculateSum(1, 2, 3, 4, 5); // 15

const originalArray = [1, 2, 3];
const newArray = [...originalArray, 4, 5];
console.log(newArray); // [1, 2, 3, 4, 5]

export {calculateSum, originalArray, newArray};







juurikansiossa: hyteprojekti on kansioiden lisäksi:

hyteproject/.env:

DB_HOST=localhost
DB_USER=healthuser
DB_PASSWORD=Healthpass!123
DB_NAME=HealthDiary
JWT_SECRET=sfc005rgfy
JWT_EXPIRES_IN=1d

ja jonkun verran muita tuloksia. Lisätietoa saa kysymällä.

muutokset tehty: 11.3